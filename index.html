<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Worms Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #87CEEB, #98FB98);
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #gameCanvas {
            display: block;
            background: #87CEEB;
            cursor: crosshair;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 10;
        }
        
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-size: 12px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            z-index: 10;
        }
        
        .player-info {
            margin-bottom: 10px;
            padding: 5px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
        }
        
        .current-player {
            background: rgba(255,255,0,0.3);
        }
        
        .health-bar {
            width: 100px;
            height: 10px;
            background: #333;
            border-radius: 5px;
            overflow: hidden;
            margin-top: 3px;
        }
        
        .health-fill {
            height: 100%;
            background: #4CAF50;
            transition: width 0.3s;
        }
        
        #trajectory {
            position: absolute;
            top: 50%;
            right: 10px;
            transform: translateY(-50%);
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            z-index: 10;
        }
        
        .slider {
            margin: 5px 0;
        }
        
        input[type="range"] {
            width: 150px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="ui">
            <div id="player1" class="player-info current-player">
                <div>Player 1 (Red)</div>
                <div class="health-bar">
                    <div class="health-fill" id="health1" style="width: 100%"></div>
                </div>
            </div>
            <div id="player2" class="player-info">
                <div>Player 2 (Blue)</div>
                <div class="health-bar">
                    <div class="health-fill" id="health2" style="width: 100%"></div>
                </div>
            </div>
            <div style="margin-top: 15px;">
                <div>Wind: <span id="windDisplay">0</span></div>
                <div>Turn: <span id="turnDisplay">1</span></div>
            </div>
        </div>
        
        <div id="trajectory">
            <div class="slider">
                <label>Angle: <span id="angleValue">45</span>Â°</label><br>
                <input type="range" id="angleSlider" min="0" max="180" value="45">
            </div>
            <div class="slider">
                <label>Power: <span id="powerValue">50</span>%</label><br>
                <input type="range" id="powerSlider" min="10" max="100" value="50">
            </div>
            <button id="fireButton" style="margin-top: 10px; padding: 10px;">FIRE!</button>
        </div>
        
        <div id="controls">
            <div>Controls:</div>
            <div>A/D - Move left/right</div>
            <div>Adjust angle and power, then FIRE!</div>
            <div>Click anywhere to set trajectory direction</div>
        </div>
    </div>

    <script>
        class WormsGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                this.terrain = [];
                this.worms = [];
                this.projectiles = [];
                this.currentPlayer = 0;
                this.gameState = 'playing';
                this.wind = (Math.random() - 0.5) * 20;
                this.turn = 1;
                
                this.aimAngle = 45;
                this.aimPower = 50;
                this.isAiming = false;
                this.aimStartX = 0;
                this.aimStartY = 0;
                
                this.init();
                this.setupEventListeners();
                this.gameLoop();
            }
            
            init() {
                this.generateTerrain();
                this.createWorms();
                this.updateUI();
            }
            
            generateTerrain() {
                this.terrain = [];
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                // Generate terrain using sine waves for natural look
                for (let x = 0; x < width; x++) {
                    const baseHeight = height * 0.7;
                    const noise1 = Math.sin(x * 0.01) * 50;
                    const noise2 = Math.sin(x * 0.005) * 100;
                    const noise3 = Math.sin(x * 0.02) * 25;
                    
                    const terrainHeight = baseHeight + noise1 + noise2 + noise3;
                    this.terrain[x] = Math.max(height * 0.4, Math.min(height * 0.9, terrainHeight));
                }
            }
            
            createWorms() {
                // Player 1 worm (red)
                const x1 = this.canvas.width * 0.2;
                const y1 = this.getTerrainHeight(x1) - 20;
                this.worms.push({
                    x: x1,
                    y: y1,
                    vx: 0,
                    vy: 0,
                    health: 100,
                    color: '#FF4444',
                    player: 0,
                    radius: 8
                });
                
                // Player 2 worm (blue)
                const x2 = this.canvas.width * 0.8;
                const y2 = this.getTerrainHeight(x2) - 20;
                this.worms.push({
                    x: x2,
                    y: y2,
                    vx: 0,
                    vy: 0,
                    health: 100,
                    color: '#4444FF',
                    player: 1,
                    radius: 8
                });
            }
            
            getTerrainHeight(x) {
                x = Math.floor(Math.max(0, Math.min(this.canvas.width - 1, x)));
                return this.terrain[x];
            }
            
            setupEventListeners() {
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    if (this.gameState !== 'playing') return;
                    
                    const worm = this.worms[this.currentPlayer];
                    switch(e.key.toLowerCase()) {
                        case 'a':
                            this.moveWorm(worm, -2);
                            break;
                        case 'd':
                            this.moveWorm(worm, 2);
                            break;
                    }
                });
                
                // Mouse controls for aiming
                this.canvas.addEventListener('mousedown', (e) => {
                    if (this.gameState !== 'playing') return;
                    
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    const worm = this.worms[this.currentPlayer];
                    this.calculateAimFromMouse(worm.x, worm.y, mouseX, mouseY);
                });
                
                // Sliders
                document.getElementById('angleSlider').addEventListener('input', (e) => {
                    this.aimAngle = parseInt(e.target.value);
                    document.getElementById('angleValue').textContent = this.aimAngle;
                });
                
                document.getElementById('powerSlider').addEventListener('input', (e) => {
                    this.aimPower = parseInt(e.target.value);
                    document.getElementById('powerValue').textContent = this.aimPower;
                });
                
                // Fire button
                document.getElementById('fireButton').addEventListener('click', () => {
                    this.fireWeapon();
                });
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                    this.generateTerrain();
                    this.createWorms();
                });
            }
            
            calculateAimFromMouse(wormX, wormY, mouseX, mouseY) {
                const dx = mouseX - wormX;
                const dy = wormY - mouseY; // Inverted because canvas Y increases downward
                
                let angle = Math.atan2(dy, Math.abs(dx)) * (180 / Math.PI);
                if (dx < 0) angle = 180 - angle;
                
                angle = Math.max(0, Math.min(180, angle));
                
                const distance = Math.sqrt(dx * dx + dy * dy);
                const power = Math.min(100, Math.max(10, distance / 3));
                
                this.aimAngle = Math.round(angle);
                this.aimPower = Math.round(power);
                
                document.getElementById('angleSlider').value = this.aimAngle;
                document.getElementById('powerSlider').value = this.aimPower;
                document.getElementById('angleValue').textContent = this.aimAngle;
                document.getElementById('powerValue').textContent = this.aimPower;
            }
            
            moveWorm(worm, dx) {
                const newX = worm.x + dx;
                const newY = this.getTerrainHeight(newX) - worm.radius;
                
                if (newX >= worm.radius && newX <= this.canvas.width - worm.radius) {
                    worm.x = newX;
                    worm.y = newY;
                }
            }
            
            fireWeapon() {
                if (this.projectiles.length > 0) return; // Wait for current projectile
                
                const worm = this.worms[this.currentPlayer];
                const angleRad = this.aimAngle * (Math.PI / 180);
                const power = this.aimPower / 100;
                
                const vx = Math.cos(angleRad) * power * 15;
                const vy = -Math.sin(angleRad) * power * 15;
                
                this.projectiles.push({
                    x: worm.x,
                    y: worm.y - worm.radius,
                    vx: vx,
                    vy: vy,
                    radius: 3,
                    gravity: 0.3,
                    bounces: 0,
                    maxBounces: 3
                });
            }
            
            updateProjectiles() {
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const proj = this.projectiles[i];
                    
                    // Apply physics
                    proj.vx += this.wind * 0.01;
                    proj.vy += proj.gravity;
                    proj.x += proj.vx;
                    proj.y += proj.vy;
                    
                    // Check terrain collision
                    if (proj.y + proj.radius >= this.getTerrainHeight(proj.x)) {
                        this.explode(proj.x, this.getTerrainHeight(proj.x), 40);
                        this.projectiles.splice(i, 1);
                        this.nextTurn();
                        continue;
                    }
                    
                    // Check worm collisions
                    for (let worm of this.worms) {
                        const dist = Math.sqrt(
                            Math.pow(proj.x - worm.x, 2) + Math.pow(proj.y - worm.y, 2)
                        );
                        
                        if (dist < proj.radius + worm.radius) {
                            const damage = 25;
                            worm.health = Math.max(0, worm.health - damage);
                            this.explode(proj.x, proj.y, 30);
                            this.projectiles.splice(i, 1);
                            this.updateUI();
                            this.nextTurn();
                            break;
                        }
                    }
                    
                    // Remove if out of bounds
                    if (proj.x < 0 || proj.x > this.canvas.width || proj.y > this.canvas.height) {
                        this.projectiles.splice(i, 1);
                        this.nextTurn();
                    }
                }
            }
            
            explode(x, y, radius) {
                // Create crater in terrain
                for (let i = x - radius; i <= x + radius; i++) {
                    if (i >= 0 && i < this.terrain.length) {
                        const distance = Math.abs(i - x);
                        const craterDepth = Math.max(0, radius - distance);
                        this.terrain[i] += craterDepth * 2;
                    }
                }
                
                // Damage nearby worms
                for (let worm of this.worms) {
                    const dist = Math.sqrt(Math.pow(worm.x - x, 2) + Math.pow(worm.y - y, 2));
                    if (dist < radius) {
                        const damage = Math.floor((radius - dist) / radius * 30);
                        worm.health = Math.max(0, worm.health - damage);
                    }
                }
                
                this.updateUI();
            }
            
            nextTurn() {
                this.currentPlayer = (this.currentPlayer + 1) % this.worms.length;
                this.turn++;
                this.wind = (Math.random() - 0.5) * 20;
                this.updateUI();
                
                // Check win condition
                const aliveWorms = this.worms.filter(w => w.health > 0);
                if (aliveWorms.length <= 1) {
                    this.gameState = 'gameOver';
                    if (aliveWorms.length === 1) {
                        alert(`Player ${aliveWorms[0].player + 1} wins!`);
                    } else {
                        alert("It's a draw!");
                    }
                }
            }
            
            updateUI() {
                document.getElementById('windDisplay').textContent = Math.round(this.wind * 10) / 10;
                document.getElementById('turnDisplay').textContent = this.turn;
                
                for (let i = 0; i < this.worms.length; i++) {
                    const healthPercent = (this.worms[i].health / 100) * 100;
                    document.getElementById(`health${i + 1}`).style.width = healthPercent + '%';
                    
                    const playerDiv = document.getElementById(`player${i + 1}`);
                    if (i === this.currentPlayer) {
                        playerDiv.classList.add('current-player');
                    } else {
                        playerDiv.classList.remove('current-player');
                    }
                }
            }
            
            render() {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw sky gradient
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(1, '#E0F6FF');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw terrain
                this.ctx.fillStyle = '#654321';
                this.ctx.beginPath();
                this.ctx.moveTo(0, this.canvas.height);
                for (let x = 0; x < this.terrain.length; x++) {
                    this.ctx.lineTo(x, this.terrain[x]);
                }
                this.ctx.lineTo(this.canvas.width, this.canvas.height);
                this.ctx.closePath();
                this.ctx.fill();
                
                // Draw grass on terrain
                this.ctx.strokeStyle = '#228B22';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                for (let x = 0; x < this.terrain.length; x++) {
                    this.ctx.moveTo(x, this.terrain[x]);
                    this.ctx.lineTo(x, this.terrain[x] - 1);
                }
                this.ctx.stroke();
                
                // Draw worms
                for (let worm of this.worms) {
                    if (worm.health <= 0) continue;
                    
                    // Worm body
                    this.ctx.fillStyle = worm.color;
                    this.ctx.beginPath();
                    this.ctx.arc(worm.x, worm.y, worm.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Worm eyes
                    this.ctx.fillStyle = 'white';
                    this.ctx.beginPath();
                    this.ctx.arc(worm.x - 3, worm.y - 2, 2, 0, Math.PI * 2);
                    this.ctx.arc(worm.x + 3, worm.y - 2, 2, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.fillStyle = 'black';
                    this.ctx.beginPath();
                    this.ctx.arc(worm.x - 3, worm.y - 2, 1, 0, Math.PI * 2);
                    this.ctx.arc(worm.x + 3, worm.y - 2, 1, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Current player indicator
                    if (worm.player === this.currentPlayer && this.gameState === 'playing') {
                        this.ctx.strokeStyle = 'yellow';
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        this.ctx.arc(worm.x, worm.y, worm.radius + 5, 0, Math.PI * 2);
                        this.ctx.stroke();
                        
                        // Draw aim line
                        const angleRad = this.aimAngle * (Math.PI / 180);
                        const aimLength = (this.aimPower / 100) * 60;
                        const aimEndX = worm.x + Math.cos(angleRad) * aimLength;
                        const aimEndY = worm.y - Math.sin(angleRad) * aimLength;
                        
                        this.ctx.strokeStyle = 'red';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.moveTo(worm.x, worm.y);
                        this.ctx.lineTo(aimEndX, aimEndY);
                        this.ctx.stroke();
                        
                        // Aim arrow
                        const arrowSize = 5;
                        this.ctx.fillStyle = 'red';
                        this.ctx.beginPath();
                        this.ctx.moveTo(aimEndX, aimEndY);
                        this.ctx.lineTo(
                            aimEndX - arrowSize * Math.cos(angleRad - 0.5),
                            aimEndY + arrowSize * Math.sin(angleRad - 0.5)
                        );
                        this.ctx.lineTo(
                            aimEndX - arrowSize * Math.cos(angleRad + 0.5),
                            aimEndY + arrowSize * Math.sin(angleRad + 0.5)
                        );
                        this.ctx.closePath();
                        this.ctx.fill();
                    }
                }
                
                // Draw projectiles
                for (let proj of this.projectiles) {
                    this.ctx.fillStyle = '#FF6600';
                    this.ctx.beginPath();
                    this.ctx.arc(proj.x, proj.y, proj.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Trail effect
                    this.ctx.strokeStyle = 'rgba(255, 102, 0, 0.5)';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(proj.x - proj.vx, proj.y - proj.vy);
                    this.ctx.lineTo(proj.x, proj.y);
                    this.ctx.stroke();
                }
                
                // Draw wind indicator
                if (Math.abs(this.wind) > 1) {
                    const windX = this.canvas.width / 2;
                    const windY = 50;
                    const windStrength = Math.abs(this.wind) * 2;
                    
                    this.ctx.strokeStyle = this.wind > 0 ? '#00AA00' : '#AA0000';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.moveTo(windX, windY);
                    this.ctx.lineTo(windX + (this.wind > 0 ? windStrength : -windStrength), windY);
                    this.ctx.stroke();
                    
                    // Wind arrow
                    const arrowDir = this.wind > 0 ? 1 : -1;
                    this.ctx.beginPath();
                    this.ctx.moveTo(windX + arrowDir * windStrength, windY);
                    this.ctx.lineTo(windX + arrowDir * (windStrength - 10), windY - 5);
                    this.ctx.lineTo(windX + arrowDir * (windStrength - 10), windY + 5);
                    this.ctx.closePath();
                    this.ctx.fill();
                }
            }
            
            gameLoop() {
                this.updateProjectiles();
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // Start the game when page loads
        window.addEventListener('load', () => {
            new WormsGame();
        });
    </script>
</body>
</html>